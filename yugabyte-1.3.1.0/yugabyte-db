#!/usr/bin/env python

import argparse
import atexit
import json
import logging
import multiprocessing
import os
import re
import resource
import shutil
import subprocess
import sys
import time
import uuid
from datetime import datetime
from signal import SIGABRT, SIGINT, SIGTERM, SIG_DFL, signal
from threading import Thread

# Version-dependent imports
PY_VERSION = sys.version_info[0]
if sys.version_info[0] < 3:
    from urllib2 import Request, urlopen, URLError, HTTPError
else:
    from urllib.request import Request, urlopen
    from urllib.error import URLError, HTTPError

"""
Run `yugabyte-db` to start a single-node YugaByte DB process. If no options are specified,
`yugabyte-db` will assume the following default directory tree:

yugabyte
+-- yugabyte-db
+-- conf
|   |   +-- yugabyte-db.conf
|   |   +-- yb-master.conf
|   |   +-- yb-tserver.conf
+-- bin
|   |   +-- yb-master
|   |   +-- yb-tserver
+-- logs
|   |   +-- master & tserver logfiles, unify these if possible
+-- yugabyte-data
"""

# YugaByte DB configs.
YUGABYTE_DIR = os.path.dirname(os.path.realpath(__file__))
DEFAULT_CONF_DIR = os.path.join(YUGABYTE_DIR, "conf")
BIN_DIR = os.path.join(YUGABYTE_DIR, "bin")
DEFAULT_DATA_DIR = os.path.join(YUGABYTE_DIR, "yugabyte-data")
DEFAULT_LOG_DIR = os.path.join(YUGABYTE_DIR, "yugabyte-logs")
DEFAULT_CONF = os.path.join(DEFAULT_CONF_DIR, "yugabyte-db.conf")
DEFAULT_MASTER_PORT = 7100
DEFAULT_TSERVER_PORT = 9100
DEFAULT_YSQL_PORT = 5433
DEFAULT_YCQL_PORT = 9042
# TODO: Bug where webserver must be initiated with port 9000.
DEFAULT_WEBSERVER_PORT = 9000
# TODO: Add api port options in yugaware. It has to be 9000 no matter what right now.
DEFAULT_API_PORT = 9000
VERSION_METADATA_PATH = os.path.join(YUGABYTE_DIR, "version_metadata.json")
YUGABYTE_API_CLIENT_PROGRAMS = {
    "ysql": "ysqlsh",
    "ycql": "cqlsh",
}
YUGAWARE_CONF = os.path.join(DEFAULT_CONF_DIR, "application.default.conf")
WEBSERVER_DB = "system_wbsvr"


class YugaByteProcessManager(object):
    def __init__(self):
        self.configs = None
        self.processes = {}
        self.stop_callhome = False

    # Starts YugaByte DB node.
    def start(self):
        self.validate_resources()
        Output.print_and_log("Starting YugaByte DB...")
        self.set_signals(self.kill_yugabyte)
        atexit.register(self.kill_yugabyte)
        self.start_processes()

    # Prints status of YugaByte DB.
    def status(self):
        if os.path.isdir(self.configs.saved_data.get("data_dir")):
            if self.get_failed_processes():
                Output.print_out("YugaByte DB is not running.")
            Output.print_out(self.get_status_string())
        else:
            Output.print_out("YugaByte DB is not running.")

    # Prints YugaByte DB version.
    def version(self):
        title = "YugaByte DB Information"
        with open(VERSION_METADATA_PATH) as metadata:
            data = json.load(metadata)
            info_kv_list = [
                ("Version", "{}-b{}".format(data.get("version_number"), data.get("build_number"))),
                ("Build Time", data.get("build_timestamp")),
                ("Build Hash", data.get("git_hash"))]
            Output.print_out(self.get_status_string())

    # Starts an interactive YSQL shell.
    def connect_ysql(self):
        if self.get_failed_processes():
            Output.log_error_and_exit("YugaByte DB is not running. Cannot connect to YSQL.")
        ysql_proxy = YsqlProxy(self.configs.saved_data.get("ysql_port"))
        ysql_proxy.connect()

    # Starts an interactive YCQL shell.
    def connect_ycql(self):
        if self.get_failed_processes():
            Output.log_error_and_exit("YugaByte DB is not running. Cannot connect to YCQL.")
        path = os.path.join(BIN_DIR, YUGABYTE_API_CLIENT_PROGRAMS["ycql"])
        cmd = [path, "127.0.0.1", self.configs.saved_data.get("ycql_port")]
        os.execv(path, cmd)

    # Create retail database if it does not exist.
    def create_demo_retail(self):
        if self.get_failed_processes():
            Output.log_error_and_exit("YugaByte DB is not running. Cannot create sample database.")

        demo_db = "yb_demo_retail"
        ysql_proxy = YsqlProxy(self.configs.saved_data.get("ysql_port"))
        if not ysql_proxy.db_exists(demo_db):
            Output.print_out("Initializing demo retail database...")
            # Create demo database.
            Output.log("Creating database {}...".format(demo_db))
            _, err = ysql_proxy.create_db(demo_db)
            if err:
                Output.log_error_and_exit("Failed to create {} database: {}".format(demo_db, err))

            # Populate demo database.
            Output.log("Populating {} with sample data...".format(demo_db))
            files = []
            for name in ("schema.sql", "products.sql", "users.sql", "reviews.sql", "orders.sql"):
                files.append(os.path.join(YUGABYTE_DIR, "share", name))
            _, err = ysql_proxy.load_files(files, db=demo_db)
            if err:
                Output.log_error_and_exit("Failed to populate data to {}: {}".format(demo_db, err))

            msg = "Successfully loaded sample database!"
            Output.log(msg)
            Output.print_out(
                Output.make_green(msg) +
                "\n\n################################\n"
                "#  WELCOME TO THE retail DEMO  #\n"
                "################################\n"
                "    Database: yb_demo_retail\n"
                "    |_ users\n"
                "    |_ products\n"
                "    |_ orders\n"
                "    |_ reviews\n\n"
                "################################\n"
                "# NEXT STEP: RUN THE DEMO\n"
                "################################\n"
                "$ yugabyte-db demo run retail\n\n"
            )
        else:
            Output.log_error_and_exit(
                "Retail sample database has already been created. "
                "Use `yugabyte-db demo run retail` to interact with it.")

    # Run YSQL shell in retail database.
    def run_demo_retail(self):
        if self.get_failed_processes():
            Output.log_error_and_exit("YugaByte DB is not running. Cannot connect to YSQL.")

        demo_db = "yb_demo_retail"
        ysql_proxy = YsqlProxy(self.configs.saved_data.get("ysql_port"))
        if ysql_proxy.db_exists(demo_db):
            # TODO: Add more commands.
            website = Output.make_underline(
                "https://docs.yugabyte.com/latest/quick-start/explore-ysql/")
            Output.print_out(
                "\n################################\n"
                "#     SAMPLE QUERIES TO TRY    #\n"
                "################################\n\n"
                "# JOINS (find user details of orders):\n"
                "    %s users.id, users.name, users.email, orders.id, orders.total\n"
                "        %s orders %s users %s orders.user_id=users.id\n"
                "        %s 10;\n\n" % tuple([Output.make_cyan(kw) for kw in (
                    "SELECT", "FROM", "INNER JOIN", "ON", "LIMIT")])
            )
            Output.print_out(
                "For more, go to {}\n".format(website)
            )
            ysql_proxy.connect(db="yb_demo_retail")
        else:
            Output.log_error_and_exit(
                "Retail demo has not been created. Run `yugabyte-db demo create retail`.")

    # Destroy retail database if it exists.
    def destroy_demo_retail(self):
        if self.get_failed_processes():
            Output.log_error_and_exit("YugaByte DB is not running. Cannot destroy sample database.")

        demo_db = "yb_demo_retail"
        ysql_proxy = YsqlProxy(self.configs.saved_data.get("ysql_port"))
        if not ysql_proxy.db_exists(demo_db):
            Output.log_error_and_exit(
                "Failed to destroy database. Retail demo has not been created.")
        else:
            _, err = ysql_proxy.drop_db(demo_db)
            if err:
                Output.log_error_and_exit("Failed to drop database {}: {}".format(demo_db, err))
            msg = "Successfully destroyed demo database {}.".format(demo_db)
            Output.print_and_log(msg)

    # Checks yb-master and yb-tserver are running. Returns failed processes.
    # TODO: Check postmaster.pid.
    def get_failed_processes(self):
        failed_processes = []
        for process in ("master", "tserver"):
            if not ProcessManager.is_process_running(
                    process, self.configs.saved_data.get("data_dir")):
                failed_processes.append("yb-{}".format(process))
        return failed_processes

    # Called after receiving certain signals or on exit. Kills all subprocesses.
    def kill_yugabyte(self, signum=None, frame=None):
        if signum:
            Output.log("Received signal: {}".format(signum), logging.DEBUG)
        Output.print_and_log("Shutting down...")
        cur_pid = os.getpid()
        pgid = os.getpgid(cur_pid)
        if not pgid:
            Output.log_error_and_exit(
                "PGID could not be found for PID {}. Is YugaByte DB running?".format(cur_pid))

        self.set_signals(SIG_DFL)

        for p in self.processes.values():
            p.delete_pidfile()

        try:
            # Kill process group instead of self.processes to ensure
            # any spawned child processes are killed
            os.killpg(pgid, SIGTERM)
            Output.log_error_and_exit(
                "YugaByte DB may not have terminated properly... "
                "Please check PGID {}.".format(pgid))
        except OSError as err:
            Output.log_error_and_exit(
                "Failed to kill PGID {}... Is YugaByte DB running?\n{}".format(pgid, str(err)))

    # Starts yb-master, yb-tserver, and yugaware processes.
    # After initializing, creates a callhome thread.
    def start_processes(self):
        common_gflags = [
            "--stop_on_parent_termination",
            "--undefok=stop_on_parent_termination",
            "--fs_data_dirs={}".format(self.configs.saved_data.get("data_dir")),
        ]
        master_address = "127.0.0.1:{}".format(self.configs.saved_data.get("master_port"))
        tserver_address = "127.0.0.1:{}".format(self.configs.saved_data.get("tserver_port"))
        yb_master_cmd = [os.path.join(BIN_DIR, "yb-master")] + common_gflags + \
            ["--master_addresses={}".format(master_address),
             "--rpc_bind_addresses", master_address,
             "--replication_factor", "1",
             "--use_initial_sys_catalog_snapshot",
             "--server_dump_info_path",
             os.path.join(self.configs.saved_data.get("data_dir"), "master-info"),]
        if self.configs.saved_data.get("master_flags"):
            yb_master_cmd.extend(
                ["--{}".format(flag) for flag in \
                    self.configs.saved_data.get("master_flags").split(",")])

        yb_tserver_cmd = [os.path.join(BIN_DIR, "yb-tserver")] + common_gflags + \
            ["--tserver_master_addrs={}".format(master_address),
             "--rpc_bind_addresses", tserver_address,
             "--cql_proxy_bind_address",
             "127.0.0.1:{}".format(self.configs.saved_data.get("ycql_port")),
             "--server_dump_info_path",
             os.path.join(self.configs.saved_data.get("data_dir"), "tserver-info"),
             "--start_pgsql_proxy", "--pgsql_proxy_bind_address",
             "127.0.0.1:{}".format(self.configs.saved_data.get("ysql_port")),
             "--server_dump_info_path",
             os.path.join(self.configs.saved_data.get("data_dir"), "tserver-info"),]
        if self.configs.saved_data.get("tserver_flags"):
            yb_tserver_cmd.extend(
                ["--{}".format(flag) for flag in \
                    self.configs.saved_data.get("tserver_flags").split(",")])

        yw_cmd = [
            os.path.join(BIN_DIR, "yugaware"), "-Dconfig.file={}".format(YUGAWARE_CONF),
            "-Dplay.evolutions.db.default.autoApply=true",
            "-Dhttp.port={}".format(self.configs.saved_data.get("webserver_port")),
        ]

        self.processes = {
            "master": YBProcessManager(
                "master", yb_master_cmd, self.configs.saved_data.get("log_dir"),
                self.configs.saved_data.get("data_dir")),
            "tserver": YBProcessManager(
                "tserver", yb_tserver_cmd, self.configs.saved_data.get("log_dir"),
                self.configs.saved_data.get("data_dir")),
        }

        if self.configs.saved_data.get("webserver_enabled"):
            self.processes["yugaware"] = ProcessManager(
                "yugaware", yw_cmd, self.configs.saved_data.get("log_dir"),
                self.configs.saved_data.get("data_dir"))

        for p in self.processes.values():
            pid = p.get_pid()
            if pid:
                Output.print_out("YugaByte DB is already running!")
                # Clear self.processes so kill_yugabyte() doesn't kill existing processes.
                self.processes = {}
                return

        is_first_run = True
        callhome_thread = None
        self.stop_callhome = False
        while True:
            should_callhome = False

            # Delete corrupted data dirs left from interrupting yb-master and yb-tserver startup.
            if not self.is_yb_initialized() and os.path.exists(self.configs.saved_data.get("data_dir")):
                Output.print_and_log(
                    "Found data from failed initialization in {}. Removing...".format(
                        self.configs.saved_data.get("data_dir")))
                shutil.rmtree(self.configs.saved_data.get("data_dir"))

            # Create data directory.
            if not os.path.exists(self.configs.saved_data.get("data_dir")):
                Output.log(
                    "Creating data directory {}.".format(self.configs.saved_data.get("data_dir")))
                os.makedirs(self.configs.saved_data.get("data_dir"))

            # Start or initialize yb-master and yb-tserver.
            for name in ("master", "tserver"):
                process = self.processes.get(name)
                process.remove_error_logs()
                if not process.is_running():
                    process.start()
                    if not is_first_run:
                        Output.print_and_log(
                            "{} died unexpectedly. Restarting...".format(p.name), logging.ERROR)
                    should_callhome = True

            # Start or iniitialize yugaware.
            if self.configs.saved_data.get("webserver_enabled") and self.wait_yb_master():
                yw_proxy = YugaWareProxy(self.configs.saved_data.get("api_port"))
                if not self.is_yw_initialized():
                    Output.log("Initiating webserver...")
                    self.init_yw()
                    process = self.processes.get("yugaware")
                    process.start()

                    err = self.wait_yw_login(yw_proxy)
                    if err:
                        Output.log_error_and_exit(err)

                    err = yw_proxy.import_universe(self.configs.saved_data.get("master_port"))
                    if err:
                        Output.log_error_and_exit(err)

                    # Should yugabyte-db exit if features aren't disabled properly? Retry?
                    err = yw_proxy.update_features()
                    should_callhome = True
                else:
                    process = self.processes.get("yugaware")
                    if not process.is_running():
                        process.start()
                        self.wait_yw_login(yw_proxy)
                        Output.print_and_log(
                            "Webserver died unexpectedly. Restarting...", logging.ERROR)
                        should_callhome = True

            if should_callhome:
                self.callhome()

            # Print startup information and start callhome thread on first successful startup.
            if is_first_run:
                first_run_success = True
                for p in self.processes.values():
                    if not p.is_running():
                        first_run_success = False
                        break

                if first_run_success and self.is_yb_initialized() and (
                        not self.configs.saved_data.get("webserver_enabled")
                        or self.is_yw_initialized()):
                    status = self.get_status_string() + \
                        Output.make_green("YugaByte DB started successfully!\n") + \
                        Output.make_magenta(
                                "Join us on Slack at {}".format(
                                    Output.make_underline("https://www.yugabyte.com/slack\n")))
                    Output.print_out(status)

                    callhome_thread = Thread(target=self.callhome_loop)
                    callhome_thread.start()
                    is_first_run = False


            time.sleep(int(self.configs.saved_data.get("polling_interval")))

        # Stop callhome. Useful in future if we do anything after quitting.
        self.stop_callhome = True
        callhome_thread.join()

    # Initialize YW process. Creates all necessary tables. Returns false if init failed.
    def init_yw(self):
        # Create YW database.
        create_yw_db = [
            os.path.join(BIN_DIR, "ysqlsh"), "-c", "create database {};".format(WEBSERVER_DB)]
        process = subprocess.Popen(create_yw_db, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        _, err = process.communicate()
        if err:
            return False

        # Create Play evolutions table. Required for YugaWare to start up properly.
        create_play_table = [
            os.path.join(BIN_DIR, "ysqlsh"), "-d", WEBSERVER_DB, "-c",
            "create table play_evolutions (id int not null, hash varchar(255) not null, "
            "applied_at TIMESTAMP WITHOUT TIME ZONE not null, "
            "apply_script text, revert_script text, state varchar(255), last_problem text)"
        ]
        process = subprocess.Popen(
            create_play_table, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        _, err = process.communicate()
        return not err

    # Returns if yb-master and yb-tserver were properly initialized before.
    def is_yb_initialized(self):
        for info_file in ("master-info", "tserver-info", "tserver-info-redis", "tserver-info-cql"):
            if not os.path.exists(os.path.join(self.configs.saved_data.get("data_dir"), info_file)):
                return False
        return True

    # Returns if yugaware was properly initialized before.
    def is_yw_initialized(self):
        # Check YW database was created.
        list_db_cmd = [os.path.join(BIN_DIR, "ysqlsh"), "-c", "\l"]
        dbs = subprocess.Popen(
            list_db_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()[0]
        if "system" not in dbs:
            return False

        # Check Play evolutions table was created.
        list_tables_cmd = [os.path.join(BIN_DIR, "ysqlsh"), "-d", WEBSERVER_DB, "-c", "\d"]
        tables = subprocess.Popen(
            list_tables_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE).communicate()[0]
        if "play_evolutions" not in tables:
            return False
        return True

    # Rudimentary yb-admin call. TODO: update.
    def get_universe_uuid(self):
        saved_uuid = self.configs.saved_data.get("universe_uuid")
        if saved_uuid:
            return saved_uuid
        elif not self.get_failed_processes():
            cmd = [os.path.join(BIN_DIR, "yb-admin"), "get_universe_config"]
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            stdout, stderr = process.communicate()
            if stdout:
                universe_configs = stdout.split()
                if universe_configs:
                    univ_uuid = universe_configs[-1].replace('"', '')
                    self.configs.saved_data["universe_uuid"] = univ_uuid
                    self.configs.save_configs()
                    return univ_uuid
        return None

    # TODO: Use yb-admin to wait for yb-master to be ready.
    def wait_yb_master(self, timeout=8):
        time.sleep(timeout)
        return True

    # TODO: Attempt to login to yugaware to see if it's up.
    def wait_yw_login(self, yw_proxy, timeout=30):
        start_time = time.time()
        # Only the last error message is recorded if timed out.
        err = ""
        while time.time() - start_time < timeout:
            err = yw_proxy.login()
            if not err:
                return ""
            time.sleep(.5)
        return "Timeout: " + err

    # Returns pretty output table.
    def get_status_string(self):
        if self.configs.saved_data.get("webserver_enabled"):
            yw_status = "http://127.0.0.1:{}".format(self.configs.saved_data.get("webserver_port"))
        else:
            yw_status = "Disabled"

        title = Output.make_bold(Output.make_green("YugaByte DB"))
        # Make sure ascii escape characters for color encoding do not count towards char limit.
        extra_len = len(Output.make_bold(Output.make_green("")))
        status_info = [
            (Output.make_yellow("JDBC"), "postgresql://postgres@127.0.0.1:{}".format(
                self.configs.saved_data.get("ysql_port"))),
            (Output.make_yellow("YSQL"), "yugabyte-db connect ysql"),
            (Output.make_yellow("YCQL"), "yugabyte-db connect ycql"),
            (Output.make_yellow("Webserver UI"), yw_status),
            (Output.make_yellow("Data Dir"), self.configs.saved_data.get("data_dir")),
            (Output.make_yellow("Log Dir"), self.configs.saved_data.get("log_dir")),
            (Output.make_yellow("Universe UUID"), self.get_universe_uuid())
        ]
        status = "\n" + "-" * 100 + "\n"
        status += ("| {:^" + str(96 + extra_len) + "} |\n").format(title)
        status += "-" * 100 + "\n"
        for k, v in status_info:
            extra_len = len(Output.make_yellow(""))
            status += ("| {:" + str(20 + extra_len) + "}: {:<74} |\n").format(k, v)
        status += "-" * 100 + "\n"
        return status

    # Callhome loop. Sends data every minute for the first hour, then every hour after.
    def callhome_loop(self):
        num_times_called = 0
        initial_interval = 60
        final_interval = 3600
        while not self.stop_callhome:
            try:
                self.callhome()
            except URLError as e:
                Output.log("Failed to send callhome: {}".format(e), logging.ERROR)
            num_times_called += 1
            # Send callhome data more often in initial hour.
            time.sleep(initial_interval if num_times_called < 60 else final_interval)

    # Collects callhome data and sends it.
    def callhome(self):
        url = "http://diagnostics.yugabyte.com"
        headers = {
            "Content-Type": "application/json",
            "User-Agent": "Mozilla",
        }
        data = Diagnostics(self.configs).get_data(self.processes)
        req = Request(url, headers=headers, data=data)
        resp = urlopen(req)

    # Calls func after receiving certain exit signals.
    def set_signals(self, func):
        for sig in (SIGABRT, SIGINT, SIGTERM):
            signal(sig, func)

    # Returns true if Java 1.8 or higher is installed locally.
    def java_installed(self):
        try:
            cmd = ["java", "-version"]
            version = subprocess.check_output(cmd, stderr=subprocess.STDOUT)
            pattern = '\"(\d+\.\d+).*\"'
            return re.search(pattern, version).groups()[0] >= 1.8
        except (OSError, AttributeError, IndexError) as e:
            return False

    # Checks resource settings for current shell. Prints warning if requirements aren't met.
    def validate_resources(self):
        recommended_resources = {
            "file_size": ("RLIMIT_FSIZE", resource.RLIM_INFINITY, "-f"),
            "max_locked_memory": ("RLIMIT_MEMLOCK", resource.RLIM_INFINITY, "-l"),
            "max_memory_size": ("RLIMIT_AS", resource.RLIM_INFINITY, "-m"),
            "open_files": ("RLIMIT_NOFILE", 64000, "-n"),
            "cpu_time": ("RLIMIT_CPU", resource.RLIM_INFINITY, "-t"),
            "max_user_processes": ("RLIMIT_NPROC", 64000, "-u"),
            "virtual_memory": ("RLIMIT_VMEM", resource.RLIM_INFINITY, "-v"),
        }

        failed = []
        # If the current platform does not support the resource,
        # it won't be defined in the resource module.
        for res in recommended_resources:
            var, recommended_value, flag = recommended_resources[res]
            if hasattr(resource, var):
                # Check soft limit, not hard limit.
                value = resource.getrlimit(getattr(resource, var))[0]
                if value < recommended_value:
                    failed.append((res, value, recommended_value, flag))
        if failed:
            msg = "{}: Did not meet recommended system resource limits.\n".format(
                Output.make_red("WARNING"))
            for name, value, recommended_value, flag in failed:
                if recommended_value == resource.RLIM_INFINITY:
                    recommended_value = "unlimited"
                msg += "{0}: {1}. {2}: {3}. Use 'ulimit {4} {3}' to set.\n".format(
                    Output.make_yellow("Current " + name), value,
                    Output.make_green("Recommended"), recommended_value, flag)
            Output.print_and_log(msg, logging.WARNING)

    # Parse config file and input args. Validate them and save any new configs.
    def validate_and_set_configs(self, args):
        has_errors = False
        conf_dir = os.path.dirname(args.config)
        if not os.path.isdir(conf_dir):
            os.makedirs(conf_dir)

        self.conf_file = args.config
        self.configs = Configs.parse_config_file(self.conf_file)

        for path_args in ("data_dir", "config", "log_dir"):
            path = getattr(args, path_args, None)
            if path:
                setattr(args, path_args, os.path.realpath(path))

        if args.parser == "start":
            if args.data_dir:
                config_data_dir = self.configs.saved_data.get("data_dir")
                if (config_data_dir and os.path.exists(config_data_dir) and
                        config_data_dir != args.data_dir):
                    has_errors = True
                    # TODO: Gradefully handle this case... User should be able to override config.
                    Output.print_out(
                        "Data directory already exits at {}.".format(config_data_dir))

            if args.log_dir:
                config_log_dir = self.configs.saved_data.get("log_dir")
                if (config_log_dir and os.path.exists(config_log_dir) and
                        config_log_dir != args.log_dir):
                    Output.print_out(
                        "Old log directory already exists at {}. New logs will go to {}".format(
                            config_log_dir, args.log_dir))

            args.webserver_enabled = getattr(args, "enable_ui", None) \
                or getattr(args, "disable_ui", None)
            if args.webserver_enabled is None:
                args.webserver_enabled = self.configs.saved_data.get("webserver_enabled")
            if args.webserver_enabled:
                if not self.java_installed():
                    Output.print_out(
                        "ERROR: Java 1.8 or higher is required by YugaByte DB UI. You can:"
                        "   - Install Java 1.8 or higher (recommended)"
                        "   - Continue without the UI by passing the --disable_ui flag.")
                    has_errors = True

        if has_errors:
            sys.exit(1)

        # Override configs and defaults with user specified variables
        update_config_file = False
        for k, v in get_kv(args.__dict__):
            if (v is not None and k in self.configs.saved_data
                    and v != self.configs.saved_data.get(k)):
                self.configs.saved_data[k] = v
                update_config_file = True

        if update_config_file:
            self.configs.save_configs()

    def run(self):
        # Parent subparser for common args
        common_parser = argparse.ArgumentParser(add_help=False)
        common_parser.add_argument(
            "--config", default=DEFAULT_CONF, help="Yugabyte DB configuration file")
        # TODO: Refactor data_dir to be a list for multi-node.
        common_parser.add_argument(
            "--data_dir", help="Directory where YugaByte DB will store data.")

        start_msg = "To start YugaByte DB, run '{}'.\n\n".format(
            Output.make_green("yugabyte-db start"))
        parser = PrettyArgParser(description=start_msg)
        all_parsers = {"default": parser}
        subparsers = parser.add_subparsers(dest="parser")
        for cmd, description in (
                ("start", "Start YugaByte DB."),
                ("status", "Print status of YugaByte DB."),
                ("version", "Version of YugaByte DB."),):
            subparser = subparsers.add_parser(cmd, help=description, parents=[common_parser])
            func = getattr(self, cmd, None)
            subparser.set_defaults(func=func)
            all_parsers[cmd] = subparser

        # Add ysql and ycql CLI options
        connect = subparsers.add_parser("connect", help="Connect to an API through the CLI.")
        all_parsers["connect"] = connect
        connect_subparser = connect.add_subparsers()
        for api in YUGABYTE_API_CLIENT_PROGRAMS:
            cur_parser = connect_subparser.add_parser(
                api, help="Use {} through the CLI.".format(api.upper()), parents=[common_parser])
            func = getattr(self, "connect_{}".format(api), None)
            cur_parser.set_defaults(func=func)
            all_parsers[api] = cur_parser

        # Add YSQL demo commands.
        demo = subparsers.add_parser("demo", help="Load and interact with preset demo data.")
        all_parsers["demo"] = demo
        demo_subparser = demo.add_subparsers()

        # TODO: Make below code readable...
        create_help = "Create sample database if it does not exist yet."
        create_demo = demo_subparser.add_parser("create", help=create_help)
        create_demo_subparser = create_demo.add_subparsers()
        run_help = "Open interactive shell in sample database."
        run_demo = demo_subparser.add_parser("run", help=run_help)
        run_demo_subparser = run_demo.add_subparsers()
        destroy_help = "Destroy sample database."
        destroy_demo = demo_subparser.add_parser("destroy", help=destroy_help)
        destroy_demo_subparser = destroy_demo.add_subparsers()
        for demo_type, demo_help in (
                ("retail", "Retail is a database with products, users, orders, and reviews."),):
            for action, action_help, cur_subparser in (
                    ("create", create_help, create_demo_subparser),
                    ("destroy", destroy_help, destroy_demo_subparser),
                    ("run", run_help, run_demo_subparser)):
                help_msg = "{} {}".format(action_help, demo_help)
                cur_parser = cur_subparser.add_parser(
                    demo_type, help=help_msg, parents=[common_parser])
                func = getattr(self, "{}_demo_{}".format(action, demo_type), None)
                cur_parser.set_defaults(func=func)
                all_parsers["{}_{}".format(action, demo_type)] = cur_parser

        # Commands that can alter configuration file.
        for cmd in ("start",):
            cur_parser = all_parsers[cmd]
            cur_parser.add_argument(
                "--log_dir", help="Directory to store YugaByte DB logs.")
            cur_parser.add_argument(
                "--ycql_port", help="Port on which YCQL will run.")
            cur_parser.add_argument(
                "--ysql_port", help="Port on which YSQL will run.")
            cur_parser.add_argument(
                "--master_port", help="Port on which yb-master will run.")
            cur_parser.add_argument(
                "--tserver_port", help="Port on which yb-tserver will run.")
            cur_parser.add_argument(
                "--webserver_port", help="Port on which webserver will run.")
            cur_parser.add_argument(
                "--api_port", help="Port on which webserver API will run.")

            group = cur_parser.add_mutually_exclusive_group()
            group.add_argument(
                "--enable_ui", help="Enable webserver UI.", action="store_true", default=None)
            group.add_argument(
                "--disable_ui", help="Disable webserver UI.", action="store_false", default=None)
            # Hidden commands for development/advanced users
            cur_parser.add_argument(
                "--polling_interval", default=5, help=argparse.SUPPRESS)
            cur_parser.add_argument(
                "--master_flags", help=argparse.SUPPRESS)
            cur_parser.add_argument(
                "--tserver_flags", help=argparse.SUPPRESS)

        if not sys.argv[1:]:
            parser.print_help()
            return

        args = parser.parse_args()
        self.validate_and_set_configs(args)

        log_dir = self.configs.saved_data.get("log_dir")
        if not os.path.exists(log_dir):
            os.makedirs(log_dir)

        logging.basicConfig(
            level=logging.DEBUG, filename=os.path.join(log_dir, "yugabyte-db.log"), filemode="a",
            format="[%(filename)s:%(lineno)d] %(asctime)s %(levelname)s: %(message)s")
        args.func()


class Configs(object):
    def __init__(self, config_file):
        self.saved_data = {
            "data_dir": DEFAULT_DATA_DIR,
            "log_dir": DEFAULT_LOG_DIR,
            "master_port": DEFAULT_MASTER_PORT,
            "tserver_port": DEFAULT_TSERVER_PORT,
            "ysql_port": DEFAULT_YSQL_PORT,
            "ycql_port": DEFAULT_YCQL_PORT,
            "webserver_port": DEFAULT_WEBSERVER_PORT,
            "api_port": DEFAULT_API_PORT,
            "universe_uuid": "",
            "polling_interval": "5",
            "yb_demo_retail": False,
            "webserver_enabled": True,
            "master_flags": "",
            "tserver_flags": "",
        }
        self.config_file = config_file

    # Saves current configs to config file.
    def save_configs(self):
        with open(self.config_file, "w+") as f:
            json.dump(self.saved_data, f, indent=4)

    # Custom parser for reading config file.
    @staticmethod
    def parse_config_file(config_file):
        configs = Configs(config_file)
        if os.path.isfile(config_file):
            try:
                with open(config_file) as f:
                    configs.saved_data.update(json.load(f))
            except ValueError as e:
                Output.log_error_and_exit(
                    "Failed to read config file {}: {}".format(config_file, str(e)))
        return configs


class ProcessManager(object):
    def __init__(self, name, cmd, log_dir, data_dir):
        self.name = name
        self.cmd = cmd
        self.log_dir = log_dir
        self.data_dir = data_dir
        self.pidfile = os.path.join(self.data_dir, "{}.pid".format(name))
        self.process = None
        # TODO: Get uptime of process.
        self.start_time = None

    # Start process. Creates pidfile and corresponding output logs.
    def start(self):
        out_log = os.path.join(self.log_dir, "{}.out".format(self.name))
        err_log = os.path.join(self.log_dir, "{}.err".format(self.name))
        with open(out_log, "a") as out_log, open(err_log, "a") as err_log:
            self.process = subprocess.Popen(self.cmd, stdout=out_log, stderr=err_log)
            self.start_time = time.time()
        # TODO: Redirect YW logs to yugabyte-logs
        with open(self.pidfile, "w+") as pid_file:
            pid_file.write(str(self.process.pid))
            Output.log("{} running with PID {}.".format(self.name, self.process.pid), logging.DEBUG)

    # Returns pid of this process if it's running.
    def get_pid(self):
        if os.path.exists(self.pidfile):
            if self.process:
                return self.process.pid
            else:
                with open(self.pidfile, "r") as f:
                    try:
                        pid = int(f.readline())
                    except ValueError as e:
                        Output.log(
                            "Could not parse int PID from {}. Deleting file.".format(self.pidfile),
                            logging.DEBUG)
                        self.delete_pidfile()
                        return None
                command = ProcessManager.get_command(pid)
                if command and self.name in command:
                    return pid

            Output.log(
                "Pidfile {} was not properly deleted."
                "Contained PID {}. Deleting file.".format(self.pidfile, pid), logging.DEBUG)
            self.delete_pidfile()
        return None

    # Kills self.process if it exists.
    def kill(self):
        if self.process:
            self.process.kill()
        else:
            pid = self.get_pid()
            if pid:
                try:
                    os.kill(pid, SIGTERM)
                except OSError as e:
                    pass
        self.delete_pidfile()

    # Delete corresponding pidfile for this process.
    def delete_pidfile(self):
        if os.path.exists(self.pidfile):
            try:
                os.remove(self.pidfile)
            except OSError as e:
                if os.path.exists(self.pidfile):
                    Output.log_error_and_exit("Failed to delete {}.".format(self.pidfile))
        self.start_time = None

    # Check fatal errors in fatal/error logs, if any. Overwritten in YBProcessManager
    def check_fatals(self):
        pass

    # Returns process status.
    def is_running(self):
        self.check_fatals()
        return self.get_pid() and self.process and self.process.poll() is None

    # Returns the command that was run with the input pid.
    @staticmethod
    def get_command(pid):
        try:
            return subprocess.check_output(["ps", "-p", str(pid), "-o", "command="])
        except subprocess.CalledProcessError as e:
            return ""

    # Returns if process called name is running.
    @staticmethod
    def is_process_running(name, pid_dir):
        return ProcessManager(name, cmd="", log_dir="", data_dir=pid_dir).get_pid() is not None


class YBProcessManager(ProcessManager):
    def __init__(self, name, cmd, log_dir, data_dir):
        super(YBProcessManager, self).__init__(name, cmd, log_dir, data_dir)
        self.data_log_path = "{}/yb-data/{}/logs".format(data_dir, self.name)
        self.error_log = "{}/yb-{}.ERROR".format(self.data_log_path, self.name)


    def start(self):
        # Remove old logs as timestamped logs should have already been created.
        self.remove_error_logs()

        super(YBProcessManager, self).start()

        # Add symlink to the logs from log directory.
        log_path = os.path.join(self.log_dir, self.name)
        if not os.path.islink(log_path):
            try:
                os.symlink(self.data_log_path, log_path)
            except OSError as e:
                Output.log(
                    "Failed to create symlink from {} to {}".format(self.data_log_path, log_path),
                    logging.ERROR)

    def remove_error_logs(self):
        if os.path.isfile(self.error_log):
            os.remove(self.error_log)

    def check_fatals(self):
        # Error logs contain port information, but fatal logs don't.
        address_error_1 = "Could not start on address"
        address_error_2 = "Error binding socket to "
        address_error_3 = "Is another postmaster already running on port "
        if os.path.isfile(self.error_log):
            with open(self.error_log) as log:
                for line in log.readlines():
                    if address_error_1 in line:
                        err_msg = line.split(address_error_1)
                        # Try to find address, otherwise log entire error message.
                        if len(err_msg) == 2:
                            err_msg = err_msg[1]
                        else:
                            err_msg = line
                        Output.log_error_and_exit(
                            "Failed to bind to address: {}".format(err_msg))
                    elif address_error_2 in line:
                        err_msg = line.split(address_error_2)[1]
                        address = err_msg.split()[0]
                        Output.log_error_and_exit(
                            "Failed to bind to address: {}".format(address))
                    elif address_error_3 in line:
                        err_msg = line.split(address_error_3)
                        # Try to find address, otherwise log entire error message.
                        if len(err_msg) == 2:
                            err_msg = err_msg[1].split()[0]
                            Output.log_error_and_exit(
                                "Failed to bind to port: {}.".format(err_msg))
                        else:
                            Output.log_error_and_exit(
                                "Failed to bind to address: {}".format(err_msg))


class Diagnostics(object):
    def __init__(self, configs):
        self.configs = configs

    # Collects data.
    def get_data(self, processes):
        payload = {
            "data_dir_size": self.get_dir_size(self.configs.saved_data.get("data_dir")),
            "num_cpus": multiprocessing.cpu_count(),
            "master_flags": self.configs.saved_data.get("master_flags"),
            "tserver_flags": self.configs.saved_data.get("tserver_flags")
        }
        for p in processes.values():
            payload["{}_status".format(p.name)] = "UP" if p.is_running() else "DOWN"
            if p.start_time:
                payload["{}_start_time".format(p.name)] = p.start_time

        data = {
            "cluster_uuid": "312b7810-1752-4fe2-94f1-8d2f6fc25251",
            "node_uuid": "312b7810-1752-4fe2-94f1-8d2f6fc25251",
            "server_type": "yugabyte-db",
            "timestamp": int(time.time()),
            "payload": payload
        }
        return json.dumps(data)

    def get_dir_size(self, dirname):
        size = 0
        for path, _, files in os.walk(dirname):
            for f in files:
                filepath = os.path.join(path, f)
                # Check that the file is not a symlink
                if os.path.isfile(filepath):
                    size += os.path.getsize(filepath)
        return size


# Proxy for ysqlsh commands.
class YsqlProxy(object):
    def __init__(self, port, path=os.path.join(BIN_DIR, YUGABYTE_API_CLIENT_PROGRAMS["ysql"])):
        self.port = str(port)
        self.path = path

    # Starts interactive YSQL shell.
    def connect(self, db=None):
        cmd = [self.path, "-p", self.port]
        if db:
            cmd.extend(["-d", db])
        os.execv(self.path, cmd)

    # Checks if db exists.
    # Note that this will return false if ysqlsh can't connect, even if db exists.
    def db_exists(self, db):
        cmd = [self.path, "-p", self.port, "-q", "-c", "\\t", "-c",
            "select datname from pg_catalog.pg_database where datname='{}'".format(db)]
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = p.communicate()
        return out.strip() == db

    # Creates specified db.
    def create_db(self, db):
        cmd = [self.path, "-p", self.port, "-c", "create database {}".format(db)]
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = p.communicate()
        return out, err

    # Deletes specified db.
    def drop_db(self, db):
        cmd = [self.path, "-p", self.port, "-c", "drop database {}".format(db)]
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = p.communicate()
        return out, err

    # Runs ysqlsh with specified files.
    def load_files(self, filepaths, db=None):
        cmd = [self.path, "-p", self.port]
        if db:
            cmd.extend(["-d", db])
        for path in filepaths:
            cmd.extend(["-f", path])
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = p.communicate()
        return out, err


# Currently unused. Useful for getting diagnostics that are available only through logs.
class LogAnalyzer(object):
    unsupported_error = "not supported yet"
    def __init__(self, logfile):
        self.logfile = logfile
        # Flag to stop tailing the logfile.
        self.kill_thread = False
        self.unsupported_commands = []

    def analyze(self):
        lines = self.tail()
        for line in lines:
            if LogAnalyzer.unsupported_error in line:
                # Get the command logged right before error message
                cmd = line.split("not supported yet")[0].split()[-1]
                self.unsupported_commands.append(cmd)

    # Generator that continually returns last line of logfile.
    def tail(self):
        with open(self.logfile) as open_file:
            open_file.seek(0, 2)
            while not self.kill_thread:
                line = open_file.readline()
                if not line:
                    time.sleep(0.1)
                    continue
                yield line

# Manages API calls to YW.
class YugaWareProxy(object):
    def __init__(self, api_port, univ_name="local-universe"):
        self.univ_name = univ_name
        self.api_token = ""
        self.cust_uuid = ""
        self.url = "http://localhost:{}/api/v1".format(api_port)

    # Retrieves permanent api_token. Returns error, if any.
    def login(self):
        try:
            target = self.url + "/login"
            headers = {
                "Content-Type": "application/json",
                "User-Agent": "Mozilla",
            }
            data = '{"email": "admin", "password": "admin"}'
            req = Request(target, headers=headers, data=data)
            resp = urlopen(req)
            session_data = json.loads(resp.read())
            auth_token = session_data["authToken"]
            self.cust_uuid = session_data["customerUUID"]
            # Auth token will expire, so get API token instead.
            target = "{}/customers/{}/api_token".format(self.url, self.cust_uuid)
            headers = {
                "X-Auth-Token": auth_token,
                "User-Agent": "Mozilla",
            }
            req = Request(target, headers=headers)
            req.get_method = lambda: "PUT"
            resp = urlopen(req)
            api_data = json.loads(resp.read())
            self.api_token = api_data["apiToken"]
            return None
        except (ValueError, HTTPError, URLError, KeyError) as e:
            return "Failed to log into webserver. {}".format(e)

    # Import local universe into YW. Returns error, if any.
    def import_universe(self, master_port):
        target = "{}/customers/{}/universes/import".format(self.url, self.cust_uuid)
        headers = {
            "X-AUTH-YW-API-TOKEN": self.api_token,
            "User-Agent": "Mozilla",
            "Content-Type": "application/json",
        }
        data = {
            "cloudProviderType": "other",
            "currentState": "BEGIN",
            "masterAddresses": "127.0.0.1:{}".format(master_port),
            "universeName": self.univ_name,
            "universeUUID": "",
        }

        Output.log("Importing YugaByte into webserver...")
        try:
            Output.log("Importing master.", logging.DEBUG)
            req = Request(target, headers=headers, data=json.dumps(data))
            resp = json.loads(urlopen(req).read())
            checks = resp.get("checks")
            Output.log("Import master payload: {}".format(resp), logging.DEBUG)
            if checks and not all(check == 'OK' for check in checks.values()):
                Output.log_error_and_exit(
                    "Failed to import local universe into webserver: checks failed.")

            # Set the universeUUID that YW returns.
            data["universeUUID"] = resp.get("universeUUID")

            Output.log("Importing tserver.", logging.DEBUG)
            data["currentState"] = "IMPORTED_MASTERS"
            req = Request(target, headers=headers, data=json.dumps(data))
            resp = json.loads(urlopen(req).read())
            checks = resp.get("checks")
            Output.log("Import tserver payload: {}".format(resp), logging.DEBUG)
            if checks and not all(check == 'OK' for check in checks.values()):
                Output.log_error_and_exit(
                    "Failed to import local universe into webserver: checks failed.")

            Output.log("Finalizing import.", logging.DEBUG)
            data["currentState"] = "IMPORTED_TSERVERS"
            req = Request(target, headers=headers, data=json.dumps(data))
            resp = json.loads(urlopen(req).read())
            checks = resp.get("checks")
            Output.log("Finalizing import payload: {}".format(resp), logging.DEBUG)
            # Node exporter does not matter for local universes and will fail on import.
            if "node_exporter_ip_error_map" in checks:
                del[checks["node_exporter_ip_error_map"]]
            if checks and not all(check == 'OK' for check in checks.values()):
                Output.log_error_and_exit(
                    "Failed to import local universe into webserver: checks failed.")
        except (ValueError, HTTPError, URLError, KeyError) as e:
            return "Failed to import local universe into YW with payload: {}.\n" \
                "Got error: {}".format(data, e)

        Output.log("Import succeeded!")
        return None

    # Disables/hides paid services on UI.
    def update_features(self):
        target = "{}/customers/{}".format(self.url, self.cust_uuid)
        headers = {
            "X-AUTH-YW-API-TOKEN": self.api_token,
            "User-Agent": "Mozilla",
            "Content-Type": "application/json",
        }
        data = {
            "code": "admin",
            "name": "admin",
            "email": "admin@yugabyte.com",
            "features": {
                "universe": {
                    "import": "disabled"
                },
                "config": {
                    "infra": "hidden"
                },
                "costs": {
                    "universe_list": "hidden",
                    "stats_panel": "hidden"
                },
                "main": {
                    "dropdown": "hidden",
                    "stats": "hidden",
                    "landing_page": "universes"
                },
                "menu": {
                    "dashboard": "hidden"
                },
                "universes": {
                    "details": {
                        "tasks": "disabled",
                        "backups": "disabled",
                        "health": "disabled",
                        "overview": {
                            "costs": "hidden"
                        }
                    }
                }
            }
        }

        err_msg = None
        Output.log("Updating UI with proper features...")
        try:
            req = Request(target, headers=headers, data=json.dumps(data))
            req.get_method = lambda: "PUT"
            resp = json.loads(urlopen(req).read())
            if resp.get("features") != data["features"]:
                err_msg = "Failed to update features. Sent: {}.\nReceived: {}".format(data, resp)
        except (ValueError, HTTPError, URLError, KeyError) as e:
            err_msg = "Failed to update features: {}".format(e)

        if not err_msg:
            Output.log("Successfully updated features.")
        else:
            Output.log(err_msg, logging.ERROR)
        return err_msg

# Class that handles any output operations. Use print for what users should see.
# Use log for logging. ANSI escape characters should not be used for logging.
class Output(object):
    supports_color = (sys.platform != 'win32' or 'ANSICON' in os.environ) and \
        hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()
    END = u"\u001b[0m"
    BOLD = u"\u001b[1m"
    UNDERLINE = u"\u001b[4m"
    RED = u"\u001b[31m"
    GREEN = u"\u001b[32m"
    YELLOW = u"\u001b[33m"
    BLUE = u"\u001b[34m"
    MAGENTA = u"\u001b[35m"
    CYAN = u"\u001b[36m"
    map_level_to_output = {
        logging.DEBUG: logging.debug,
        logging.INFO: logging.info,
        logging.WARNING: logging.warning,
        logging.ERROR: logging.error,
        logging.CRITICAL: logging.critical
    }

    @staticmethod
    def print_out(msg):
        print(msg)

    @staticmethod
    def log(msg, level=logging.INFO):
        Output.map_level_to_output[level](msg)

    @staticmethod
    def print_and_log(msg, level=logging.INFO):
        Output.log(msg, level=level)
        Output.print_out(msg)

    @staticmethod
    def log_error_and_exit(msg):
        Output.print_and_log(msg, logging.ERROR)
        sys.exit(1)

    @staticmethod
    def make_bold(msg):
        return Output.BOLD + msg + Output.END if Output.supports_color else msg

    @staticmethod
    def make_underline(msg):
        return Output.UNDERLINE + msg + Output.END if Output.supports_color else msg

    @staticmethod
    def make_red(msg):
        return Output.RED + msg + Output.END if Output.supports_color else msg

    @staticmethod
    def make_green(msg):
        return Output.GREEN + msg + Output.END if Output.supports_color else msg

    @staticmethod
    def make_yellow(msg):
        return Output.YELLOW + msg + Output.END if Output.supports_color else msg

    @staticmethod
    def make_blue(msg):
        return Output.BLUE + msg + Output.END if Output.supports_color else msg

    @staticmethod
    def make_magenta(msg):
        return Output.MAGENTA + msg + Output.END if Output.supports_color else msg

    @staticmethod
    def make_cyan(msg):
        return Output.CYAN + msg + Output.END if Output.supports_color else msg


# Class to customize argparse output.
class PrettyArgParser(argparse.ArgumentParser):
    epilog = "Run 'yugabyte-db [command] -h' for help with specific commands."
    def __init__(self, **kwargs):
        kwargs["formatter_class"] = PrettyHelpFormatter
        kwargs["epilog"] = self.epilog
        super(PrettyArgParser, self).__init__(**kwargs)
        self._positionals.title = Output.make_yellow("Commands")
        self._optionals.title = Output.make_yellow("Flags")

    # Add epilog help message to errors.
    def error(self, message):
        self.print_usage(sys.stderr)
        err = "{} {}\n{}\n".format(Output.make_red("Error:"), message, self.epilog)
        self.exit(2, err)


# Class that capitalizes argparse help message.
class PrettyHelpFormatter(argparse.HelpFormatter):
    # Change the "Usage: "  string to yellow
    def add_usage(self, usage, actions, groups, prefix=None):
        if prefix is None:
            prefix = Output.make_yellow('Usage: ')
        super(PrettyHelpFormatter, self).add_usage(
            usage, actions, groups, prefix)


# Returns key-value pairs of input dict. Independent of python version.
def get_kv(map):
    if PY_VERSION < 3:
        return map.iteritems()
    else:
        return map.items()

if __name__ == '__main__':
    YugaByteProcessManager().run()
